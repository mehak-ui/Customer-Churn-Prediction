# -*- coding: utf-8 -*-
"""ds proj

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12cVanloMi0E_tugxiwPevkNybnoQ6zM0
"""

import pandas as pd

df = pd.read_csv("/content/customer_churn_data.csv")

df.head()

df.info()

df.isna().sum()

df.isna().sum().sum()

df["InternetService"] = df["InternetService"].fillna("")

df.isna().sum()

df.head()

df.duplicated().sum()

df.head()

df.describe()

numeric_columns_data = df.select_dtypes(include=['number'])

numeric_columns_data

numeric_columns_data.corr()

df

df["Churn"].value_counts()

import matplotlib.pyplot as plt

df["Churn"].value_counts().plot(kind="pie")
plt.title("Churn (Yes/No)")
plt.ylabel("")
plt.show()

df.head(5)

df.groupby("Churn")["MonthlyCharges"].mean()

df.groupby(["Churn","Gender"])["MonthlyCharges"].mean()

df.groupby("Churn")["Tenure"].mean()

df.head(2)

df.groupby("Churn")["Age"].mean()

df.groupby("ContractType")["MonthlyCharges"].mean()

df.groupby("ContractType")["MonthlyCharges"].mean().plot(kind="bar")
plt.ylabel("Mean Price")
plt.xlabel("Contract Type")
plt.title("Contract Type vs Mean Price")
plt.show()

df.head(2)

plt.hist(df["MonthlyCharges"])
plt.title("Histogram of monthly charges")
plt.xlabel("Monthly Charges")
plt.ylabel("Frequency")
plt.show()

plt.hist(df["Tenure"])
plt.title("Histogram of tenure")
plt.xlabel("Tenure")
plt.ylabel("Frequency")

df.columns

df.head(2)

y = df["Churn"]
X = df[["Age", "Gender", "Tenure", "MonthlyCharges"]]

y

X

X["Gender"].apply(lambda x: 1 if x == "Female" else 0)

X["Gender"] = X["Gender"].apply(lambda x: 1 if x == "Female" else 0)

y

type(X["Gender"][0])

X.head(2)

y.head(2)

y = y.apply(lambda x: 1 if x == "Yes" else 0)

y

X

from sklearn.model_selection import train_test_split
X_train , X_test , y_train , y_test = train_test_split(x,y,test_size=0.2)

X

from sklearn.preprocessing import StandardScaler

scaler = StandardScaler()

X_train = scaler.fit_transform(X_train)

import joblib
joblib.dump(scaler,"scaler.pkl")

X_test = scaler.fit_transform(X_test)

X_train

from sklearn.metrics import accuracy_score
def modelperformance(predictions):
  print("Accuracy score on model is {}".format(accuracy_score(y_test, predictions)))

from sklearn.model_selection import GridSearchCV
from sklearn.linear_model import LogisticRegression

log_model = LogisticRegression()

import warnings
warnings.filterwarnings("ignore")

log_model.fit(X_train, y_train)

x

y_pred = log_model.predict(X_test)

modelperformance(y_pred)

from sklearn.neighbors import KNeighborsClassifier

param_grid = {
    "n_neighbors" : [3,5,7,9,11],
    "weights" : ["uniform","distance"],
}

gridkm = GridSearchCV(KNeighborsClassifier(),param_grid,cv=5)

gridkm.fit(X_train, y_train)

gridkm.best_params_

y_pred = gridkm.predict(X_test)

modelperformance(y_pred)

from sklearn.svm import  SVC

snm = SVC()

param_grid = {
    "C" : [0.01,0.1,0.5,1],
    "kernel" : ["linear","rbf","poly"],
}

gridsvc = GridSearchCV(SVC(),param_grid,cv=5)

gridsvc.fit(X_train, y_train)

gridsvc.best_params_

y_pred = gridsvc.predict(X_test)

modelperformance(y_pred)

from sklearn.tree import DecisionTreeClassifier

paran_grid = {
    "criterion" : ["gini","entropy"],
    "splitter" : ["best","random"],
    "max_depth" : [None,10,20,30],
    "min_samples_split" : [2,5,10],
    "min_samples_leaf" : [1,2,4],
}

grid_tree = GridSearchCV(DecisionTreeClassifier(),paran_grid,cv=5)

grid_tree.fit(X_train, y_train)

grid_tree.best_params_

y_pred = grid_tree.predict(X_test)

y_pred

modelperformance(y_pred)

from sklearn.ensemble import RandomForestClassifier
rfc_model = RandomForestClassifier()

param_grid = {
    "n_estimators" : [32,64,128,256],
    "max_features" : [2,3,4],
    "bootstrap" : [True, False]
}

grid_rfc = GridSearchCV(RandomForestClassifier(),param_grid,cv=5)

grid_rfc.fit(X_train, y_train)

grid_rfc.best_params_

y_pred = grid_rfc.predict(X_test)

modelperformance(y_pred)

best_model = gridsvc.best_estimator_

joblib.dump(best_model,"model.pkl")

X.columns

!pip install streamlit

!pip install streamlit pyngrok

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import streamlit as st
# import numpy as np
# import pickle
# import joblib
# import numpy as np

scaler = joblib.load("scaler.pkl")
model = joblib.load("model.pkl")

st.title("Customer Churn Prediction")
st.divider()
st.write("Please enter the values and the hit the predict button for getting a prediction")
st.divider()
age = st.number_input("Enter Age", min_value=12, max_value=83, value=30)
gender = st.selectbox("Select Gender",("Male","Female"))
tenure = st.number_input("Enter Tenure", min_value=0, max_value=122, value=10)
monthly_charges = st.number_input("Enter Monthly Charges", min_value=30.0, max_value=120.0, value=75.0)
st.divider()
predictbutton = st.button("Predict")
if predictbutton:
  gender_selection = 1 if gender == "Female" else 0
  X = np.array([age,gender_selection,tenure,monthly_charges])
  X_array = scaler.transform([X])
  prediction = model.predict(X_array)[0]
  predicted = "Yes" if prediction == 1 else "No"
  st.write(f"Predicted: {predicted}")
else:
  st.write("Please hit the predict button")